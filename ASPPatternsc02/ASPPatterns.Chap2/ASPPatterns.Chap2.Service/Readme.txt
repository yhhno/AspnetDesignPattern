tip2.2 设计模式分组
GoF设计模式著作中的23种设计模式分为3组：创建型（Createtional）、结构型（Structural）和行为型（Behavioral）
tip2.2.1 创建型
创建型模式处理对象的构造和引用。它们将对象实例的实例化责任从客户代码中抽象出来，从而让代码保持松散耦合，将创建复杂对象的责任放在一个地方，这遵循了单一责任原则和分离关注点原则。
   下面就是“创建型”分组中的模式
     1.Abstract Factory（抽象工厂）模式： 提供一个接口来创建一组相关的对象
	 2.Factory Method（工厂方法）模式： 支持使用一个类来委托创建有效对象的责任。 第5章将讨论该模式
	 3.Builder(生成器)模式：将对象本身的构造分离出来，从而能够构造对象的不同版本。
	 4.Prototype（原型）模式：能够从一个原型实例来复制或克隆类，而不是创建新实例。
	 5.Singleton(单例)模式：支持一个类只实例化一次，并只有一个可用来访问它的全局访问点。
tip2.2.2 结构型
结构型模式处理对象的组合和关系，以满足大型系统的需要。
   下面是“结构型”分组中的模式
     1.Adapter（适配器）模式：使不兼容接口的类能够一起使用。
	 2.Bridge（桥接）模式：将抽象与其实现分离，允许实现和抽象彼此独立地改变
	 3.Composite（组合）模式：可以像对待对象的单个实例那样来对待一组表示层次结构的对象。 第5章将讨论该模式
	 4.Decorator（装饰）模式：能够动态包装一个类并扩展其行为。第5章将讨论该模式
	 5.Facade（门面）模式：提供一个简单的接口并控制对一组复杂接口和子系统的访问。第6章将讨论该模式
	 6.Flyweight(亨元)模式： 提供一种在许多小类之间高效共享数据的方式。
	 7.Proxy（代理）模式：为一个实例化成本很高的更复杂的类提供一个占位符。第7章将讨论该模式
tip2.2.3 行为型
行为型模式处理对象之间在责任和算法方面的通信，这个分组中的模式将复杂行为封装起来并将其从系统控制流抽象出来，这样就使复杂系统更容易理解和维护
   下面是“行为型”分组中的模式
	1.Chain of Responsibility（责任链）模式：允许将命令动态链接起来处理请求。第8章将讨论该模式
	2.Command（命令）模式：将一个方法封装成一个对象，并将该命令的执行和它的调用者分离。第8章将讨论该模式
	3.Interpreter（解释器）模式：指定如何执行某种语言中的语句
	4.Iterator（迭代器）模式：提供以形式化的方式来导航集合的方法。
	5.Mediator（中介者）模式：定义一个对象，可以让其他两个对象进行通信而不必让他们知道彼此。
	6.Memento（备忘录）模式： 允许将对象恢复到以前的状态
	7.Observer（观察者）模式：定义一个或多个类在另一个类发生变化时接到报警。
	8.State(状态)模式：允许对象通过委托给独立的、可改变的状态对象来改变自己的行为。第5章将讲解该模式
	9.Strategy（策略）模式：能够将算法封装到一个类中并在运行时转换，以改变对象的行为。第5章中讲解该模式
	10.Template Method(模板方法)模式：定义算法流程控制，但允许子类重写或实现执行步骤。第5章将讲解该模式
	11.Visitor（访问者）模式：能够在类上执行新的功能而不影响类的结构。
虽然可供选择的模式非常多，但重要的是要理解如何选择并运用最合适的模式来解决问题。

tip2.3 如何选择和运用设计模式

